{\rtf1\ansi\ansicpg1252\cocoartf2709
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\froman\fcharset0 Times-Roman;\f2\froman\fcharset0 Times-Bold;
\f3\froman\fcharset0 Times-Italic;\f4\fswiss\fcharset0 Helvetica-Bold;\f5\fswiss\fcharset0 Helvetica;
\f6\fnil\fcharset0 Menlo-Regular;\f7\fnil\fcharset0 Menlo-Bold;\f8\fnil\fcharset0 Roboto-Regular;
\f9\fmodern\fcharset0 Courier;\f10\fnil\fcharset0 Georgia;\f11\fnil\fcharset0 Georgia-Italic;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue0;\red133\green0\blue2;
\red255\green255\blue255;\red64\green64\blue64;\red135\green136\blue117;\red0\green0\blue178;\red235\green235\blue235;
\red38\green38\blue38;\red250\green171\blue31;\red24\green25\blue27;\red19\green19\blue21;\red31\green31\blue31;
\red239\green239\blue239;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0\c84706;\cssrgb\c0\c0\c0;\cssrgb\c60000\c0\c0;
\cssrgb\c100000\c100000\c100000;\cssrgb\c31765\c31765\c31765;\cssrgb\c60000\c60000\c53333;\cssrgb\c0\c0\c75294;\cssrgb\c93725\c93725\c93725;
\cssrgb\c20000\c20000\c20000;\cssrgb\c98824\c72157\c15294;\cssrgb\c12549\c12941\c14118;\cssrgb\c9804\c9804\c10980;\cssrgb\c16078\c16078\c16078;
\cssrgb\c94902\c94902\c94902;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid1\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid101\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid201\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \expnd0\expndtw0\kerning0
KOTLIN\
{{\NeXTGraphic unknown.png \width16540 \height10840 \noorient \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\
\
// Variables\
var - reasignabila\
val - nu e reasignabila\
\
// Data Types - Primitive data types\
Int, Byte, Short, Long, Float, Double, Char, Boolean\
\
String nu e primitive, are special language support\
\
// assign a value  from if condition to a var\
Ultima expresie din if condition se va asigna catre variabila\
\
// when statement - cu argument si fara argument. Branch-urile care au conditii comune, se vor executa in ordinea declarat\uc0\u259 \
\
// null \'97 very hard to get - toate variabilele sunt non-nullable la \'eenceput\
val text: String = null; // nu merge\
val text: String? = null; // ? mark at the end of the type\
\
println(text); // null \'97 nu primim exceptia\
println(text.length) // eroare la compile time, trebuie facut safe check: text?.length sau text!!.length care daca e null iti arunca exceptia, daca e valoare o printeaz\uc0\u259 \
\
// functions, short version of function with just like of code with =, functions overloading, default values, call functions with the order of params different, varargs\
\
// break and continue - break outer - ex while in while, in al doilea while daca conditia e indeplinita dam break la tot\
\
// arrays - muttable lists and immutable lists\
listOf, mutableListOf, setOf, mutableSetOf, mapOf, mutableMapOf\
\
// mapping (.map, .mapKeys, .mapValues, .mapIndexedNotNull)\
\
// group (.group, .groupBy)\
\
// zipping (.zip, a zip b, .unzip)\
\
// association (.associateWith, .associateBy) \
\
// flatten\
\
// string representaton (.joinToString, .joinTo)\
\
// filtering (.filter, .filterIndexed, .filterNot, .filterIsIstance, .partition)\
\
// .any, .none, .all\
\
// slice, take, takeLast, drop, dropLast, takeWhile, takeLastWhile, dropWhile, dropLastWhile, chunked\
\
// .elementAt, .first, .last, .random, .isEmpty\
\
// .sum, .count, .average, .maxOrNull, .minOrNull, .sumOf\
\
// + and - to add or remove in a mutableListOf\
\
// OOP\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
in classes properties can not be uninitialised\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
metodele sunt de fapt func\uc0\u539 ii\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
primary constructor - also: putem declara properties direct in constructor\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
secondary constructor - automat va apela primary, dar se poate folosi ca un class overloading constructor\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
initializer blocks - se va executa cand o clasa va fi creat\uc0\u259  si e buna cand avem mai mult cod ca sa executam pentru a salva intr-o proprietate\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
getters and setters - override - ca sa le facem override trebuie sa definim pe acestea imediat dupa ce definim proprietatea in clasa\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
singletone - object sau cu companion object\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
lateinit\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
companion object - Ex: Calculator.sum() \
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
lazy initialization\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
enum classes - enum\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
inner classes- ex: ListView si ListViewItem\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
sealed classes\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
abstract classes - can assign some vars, in interfaces can not. Also abstarct fun must be empty\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
data class\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Interfaces - particular to each class. Ex: button on click => onclick e particular pentru fiecare button\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
object expression - onclick defined based by interface pentru fiecare la ini\uc0\u539 ializarea\
\ls1\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Delegation\
\pard\pardeftab720\partightenfactor0
\cf2 \
// Comparable - pentru clase (override fun compareTo). Ex: sa poti sorta o lista de acelasi tip de clase dupa un anume criteriu, suprascrie comparable global al clasei \
// Comparator  - override fun compare - sa poti face sa compari dupa anumite chestii, nu ceva global al clasei\
compareBy - creaza un comperator dar cu o lambda expression\
\
// sealed class - compile time sunt cunoscute colectiile de date, nu la run time\
\
// inheritance - clasele sunt closed by default(final), putem sa le extidem doar daca sunt declarate open sau abstract \
\
// serializare si deserializare - reflection - transportare de date\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // Coroutines Dispatchers
\f0\fs24 \

\f1\fs32 Main - UI operations, change UI
\f0\fs24 \

\f1\fs32 Default - by default - complex and long running calculations which blocks ui thread
\f0\fs24 \

\f1\fs32 IO - data operations, writing to db, writing to files
\f0\fs24 \

\f1\fs32 Unconfined - starts a coroutine in the caller thread, but only the first suspension point. 
\f0\fs24 After suspension it resumes the coroutine in the thread that is fully determined by the suspending function that was invoked. Does not matter where executing is.\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 // launch \{ // context of the parent \}
\f1\fs32 \cf0 \

\f0\fs24 \cf2 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 // Functions in Kotlin always return a value. If you skip the return value, the function is indeed returning Unit. Unit is similar to void in Java, though this is, in fact, an object
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // Unless a visibility modifier is applied, classes, functions or properties are public by default
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // Characters (Char) cannot directly be used as numbers. We can, however, convert them to a number when we need it: 1 val c: Char = 'c' 2 val i: Int = c.toInt()
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // Kotlin 
\f0\fs24 \

\f1\fs32 val bitwiseOr = FLAG1 or FLAG2
\f0\fs24 \

\f1\fs32 val bitwiseAnd = FLAG1 and FLAG2\cf0 \
\
\cf2 // data class
\f0\fs24 \
data class - storage mai mult
\f1\fs32 \cf0 \
\
\cf2 // Data Class Copy
\f0\fs24 \

\f1\fs32 val f1 = Forecast(Date(), 27.5f, "Shiny day\'94) 
\f0\fs24 \

\f1\fs32 val f2 = f1.copy(temperature = 30f)\cf0 \
\
\cf2 // Declaration destructuring
\f0\fs24 \

\f1\fs32 val f1 = Forecast(Date(), 27.5f, "Shiny day\'94) 
\f0\fs24 \

\f1\fs32 val (date, temperature, details) = f1
\f0\fs24 \
\

\f1\fs32 // Inline functions
\f0\fs24 \

\f1\fs32 Inline functions are a bit different from regular functions. An inline function is substituted by its code during compilation, instead of doing the real call to a function. That reduces memory allocations and runtime overhead in some situations. For instance, if we have a function as an argument, a regular function internally creates an object that contains that function. On the other hand, inline functions substitute the code of the function in the place where it is called, so it does not require an internal object for that.\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 inline function - in momentul incare este apelata, nu se mai fac jump-uri sau call-uri catre ea. nu se mai aloca nimic, compilatorul copiaza codul acolo unde se apeleaz\uc0\u259 
\f1\fs32 \cf0 \

\f0\fs24 \cf2 \
// scope coroutines - musai sa alba - lifecycle care are si isActive\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // 
\f0\fs24 A lambda expression is a simple way to define an anonymous function.\

\f1\fs32 Lambdas can substitute any function that receives an interface with a single function. So we can rewrite setOnclickListener with a lambda function.
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 view.setOnClickListener(object : OnClickListener \{ 
\f0\fs24 \
	
\f1\fs32 override fun onClick(v: View) \{ 
\f0\fs24 \
		
\f1\fs32 toast("Click\'94) 
\f0\fs24 \
	
\f1\fs32 \} 
\f0\fs24 \

\f1\fs32 \})
\f0\fs24 \

\f1\fs32 ->
\f0\fs24 \

\f1\fs32 view.setOnClickListener(\{ view -> toast("Click")\})\cf0 \
\cf2 view is not used so ->
\f0\fs24 \

\f1\fs32 view.setOnClickListener(\{ toast("Click") \}) -> \cf0 \
\cf2 view.setOnClickListener() \{ toast("Click") \} -> \cf0 \
\cf2 view.setOnClickListener \{ toast("Click") \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \
// Kotlin\
getters and setters sunt implicite pentru propriet\uc0\u259 \u539 i\
\
// Coroutines\
\
\
\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls2\ilvl0\cf2 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Suspend\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Contexts\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
runBlocking\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
jobs, waiting, cancelation\
\ls2\ilvl0\kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
async and await\
\pard\pardeftab720\partightenfactor0
\cf2 \
// AsyncTask - 
\f1\fs32 To do some work on the background and then update elements in your UI with the result of that background work. . You have to make sure to properly handle cancelling a running AsyncTask when your Activity or Fragment shuts down, since you could otherwise get a NullPointerException when the AsyncTask tries to update UI elements that don't exist anymore.
\f0\fs24 \
\
// Broadcast vs 
\f1\fs32 ConflatedBroadcast - se folosesc daca ai mai multi consumeri ca sa nu intervina race condition
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 Broadcast emite si old items
\f0\fs24 \

\f1\fs32 ConflatedBroadcast emite doar recentul
\f0\fs24 \
\
// 
\f1\fs32 Observable
\f0\fs24 \

\f1\fs32 This delegate helps us detect changes on any property we need to observe. It executes the declared lambda expression every time the set function is called. So after the new value is assigned, we receive the delegated property, the old value, and the new one. 
\f0\fs24 \

\f1\fs32 class ViewModel(val db: MyDatabase) \{ 
\f0\fs24 \

\f1\fs32 var myProperty by Delegates.observable("") \{ _, _, new ->   db.saveChanges(this, new) \}  \}\cf0 \
\
\cf2 // Vetoable
\f0\fs24 \

\f1\fs32 This delegate is similar to observable, with the difference that it runs before the value is assigned, and lets you decide whether the value must be saved or not. It can be used to check some conditions before saving a value.\cf0 \
\
\cf2 // Generics - reified types
\f0\fs24 \

\f1\fs32 Generic programming consists of writing algorithms without the need of specifying the exact type the code is going to use.
\f0\fs24 \

\f1\fs32 class TypedClass<T>
\f0\fs24 (parameter: T) \{ \
\pard\pardeftab720\partightenfactor0
\cf2 val value: T = parameter \
\}
\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 ex: \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 val t1 = TypedClass
\f0\fs24 ("Hello World!\'94) \
\pard\pardeftab720\partightenfactor0
\cf2 val t2 = TypedClass(25)\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // Variance
\f0\fs24 \

\f1\fs32 clasa user
\f0\fs24 \

\f1\fs32 clasa male: user
\f0\fs24 \

\f1\fs32 clasa female: user
\f0\fs24 \

\f1\fs32 val a: listOf<male> = \'85
\f0\fs24 \

\f1\fs32 val b: listOf<female> = \'85
\f0\fs24 \

\f1\fs32 val c: listOf<user> = a;
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // Contravariance
\f0\fs24 \

\f1\fs32 clasa user
\f0\fs24 \

\f1\fs32 clasa male: user
\f0\fs24 \

\f1\fs32 clasa female: user
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 class userCompareTo
\f0\fs24 \

\f1\fs32 class maleCompareTo
\f0\fs24 \

\f1\fs32 Nu voi putea face: val userComp: Comparable<User> = maleComparator;
\f0\fs24 \

\f1\fs32 Dar voi putea face: val maleComp: Comparable<Male> = userComparator;
\f0\fs24 \

\f1\fs32 Putem folosi user comparator fiindca e super type ca sa comparam maleComparator, fiindca e un subtype.
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // object
\f0\fs24 \

\f1\fs32 object MyClass \{\} // folosit pentru singletone, returneaza aceea\uc0\u537 i instan\u539 \u259 .
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // Dependency injection
\f0\fs24 \

\f1\fs32 Decat sa  faci initializari de alte clase in clasa unde ai nevoie, mai bine le dam c parametru. Gen clasa theatre are nevoie de clasa film, clasa proiector, clasa sala. Putem da parametrii astia in constructor ca sa fie si dinamici in functie de ce proiector e nevoie si etc. Asa este si testabila.
\f0\fs24 \

\f1\fs32 Sa faci fiecare modul independent de altul.
\f0\fs24 \

\f1\fs32 Cand o clasa foloseste alta care se initializeaza in clasa respectiva si nu se poate testa functia folosita. Se da clasa ca si parametru atunci. Sau cand se doreste sa se extinda functionalitatile unei clase. 
\f0\fs24 \
class Car(private val engine: Engine) \{\
    fun start() \{\
        engine.start()\
    \}\
\}\
\
fun main(args: Array) \{\
    val engine = Engine()\
    val car = Car(engine)\
    car.start()\
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // Nested classes
\f0\fs24 \

\f1\fs32 We can define classes inside other classes. By default, an inner class will not be able to access the members of the outer class.
\f0\fs24 \

\f1\fs32 class Outer \{
\f0\fs24 \

\f1\fs32  private val bar: Int = 1 
\f0\fs24 \

\f1\fs32 class Nested \{ 
\f0\fs24 \
	
\f1\fs32  fun foo() = 2 
\f0\fs24 \

\f1\fs32  \} 
\f0\fs24 \

\f1\fs32 \} 
\f0\fs24 \

\f1\fs32  val demo = Outer.Nested().foo() // == 2\cf0 \
\
\cf2 If we want to access to the members of the outer class, we need to declare it as an inner class:\cf0 \
\
\cf2 class Outer \{ 
\f0\fs24 \

\f1\fs32 private val bar: Int = 1 
\f0\fs24 \

\f1\fs32  inner class Inner \{ 
\f0\fs24 \

\f1\fs32   fun foo() = bar 
\f0\fs24 \

\f1\fs32 \} 
\f0\fs24 \

\f1\fs32 \} 
\f0\fs24 \

\f1\fs32 val demo = Outer().Inner().foo() // ==\cf0 \
\
\cf2 // Delegation
\f0\fs24 \

\f1\fs32 interface CanFly \{ 
\f0\fs24 \
	
\f1\fs32 fun fly() 
\f0\fs24 \

\f1\fs32  \} 
\f0\fs24 \

\f1\fs32 class Bird(f: CanFly) : CanFly by f 
\f0\fs24 \

\f1\fs32 We can indicate that a bird can fly by using the interface, but the way the bird uses to fly is defined by a delegate that comes through the constructor, so we can have different birds with different flying methods. The way an animal with wings flies is defined in another class: class AnimalWithWings : CanFly \{ 
\f0\fs24 \
	
\f1\fs32 val wings: Wings = Wings()
\f0\fs24 \
	
\f1\fs32  override fun fly() = wings.move() 
\f0\fs24 \

\f1\fs32 \} 
\f0\fs24 \

\f1\fs32 An animal with wings moves its wings to be able to fly. So now we can create a bird that flies using wings: 
\f0\fs24 \

\f1\fs32  val birdWithWings = Bird(AnimalWithWings()) 
\f0\fs24 \

\f1\fs32  birdWithWings.fly() 
\f0\fs24 \

\f1\fs32 But now wings can be used with other animals that are not birds. If we assume that bats always use wings, we could instantiate the object directly where we specify the delegation: 
\f0\fs24 \

\f1\fs32  class Bat : CanFly by AnimalWithWings() 
\f0\fs24 \

\f1\fs32 ...
\f0\fs24 \

\f1\fs32  val bat = Bat() 
\f0\fs24 \

\f1\fs32  bat.fly()\cf0 \
\
\cf2 // 
\f0\fs24 Extension functions\
Bune cand nu detii clasa, gen o importi sau ceva si ca sa nu faci inheritance la clasa respectiva pe una noua, poti sa extinzi clasa respectiva.\
Ex:\
fun String.getAllWord() \{return this.split(\'93 \'93)\}\
val a: String = \'93how are you?\'94;\
val words = a.getAllWords();\
\
// by keyword\
val abc by map; by means provided by\
\
// doAsync\
\pard\pardeftab720\partightenfactor0

\f2\b\fs32 \cf4 \cb5 doAsync
\f1\b0 \cf6  \{\
  
\f3\i \cf7 // do things in the background  1
\f1\i0 \cf6 \
\}\
\pard\pardeftab720\sa300\partightenfactor0

\f4\b \cf6 (1)
\f5\b0  In here, you can read or write to large files, download a file from the internet or do a task that will take a long time to complete. This block will execute in a background thread\
\pard\pardeftab720\partightenfactor0

\f1 \cf2 \cb1 It provides a doAsync function that executes its code in another thread, with the option to return to the main thread by calling uiThread.
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 doAsync() \{ 
\f0\fs24 \

\f1\fs32  Request(url).run() 
\f0\fs24 \

\f1\fs32  uiThread \{ longToast("Request performed") \} 
\f0\fs24 \

\f1\fs32 \}\cf0 \
\
\cf2 // with
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f6\fs28 \cf8 \cb9 inline\cf10  \cf8 fun \cf10 <T, R> with(
\f7\b receiver
\f6\b0 : T, 
\f7\b block
\f6\b0 : T.() -> R): R
\f5 \cb1 \
\pard\pardeftab720\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://github.com/JetBrains/kotlin/tree/30788566012c571aa1d3590912468d1ebe59983d/libraries/stdlib/src/kotlin/util/Standard.kt#L66"}}{\fldrslt \cf11 \cb9 \ul \ulc11 (source)}}\cb9 \
\pard\pardeftab720\sa300\partightenfactor0
\cf10 \cb5 Calls the specified function {\field{\*\fldinst{HYPERLINK "https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html#kotlin$with(kotlin.with.T,%20kotlin.Function1((kotlin.with.T,%20kotlin.with.R)))/block"}}{\fldrslt \cf11 \ul \ulc11 block}} with the given {\field{\*\fldinst{HYPERLINK "https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html#kotlin$with(kotlin.with.T,%20kotlin.Function1((kotlin.with.T,%20kotlin.with.R)))/receiver"}}{\fldrslt \cf11 \ul \ulc11 receiver}} as its receiver and returns its result. \cb1 \
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 The context object is avaiable as receiver ( this ).\
The return value is the lambda result.\
\
// let\
The context object is available as an argument ( it ).\
The return value is the lambda result.\
\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 The let function helps you with null-checks and creates a new local scope to safely perform operations. 
\f0\fs24 \

\f1\fs32 fun printCar(car: Car?) \{ 
\f0\fs24 \

\f1\fs32 val isCoupe = car?.let \{ (it.doors <= 2) \} 
\f0\fs24 \

\f1\fs32 if (isCoupe == true) \{ println("Coupes are awesome") \} \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \
let poate fi folosit pentru a invoca una sau mai multe func\uc0\u539 ii pe rezultatele lan\u539 urilor de apeluri. De exemplu, urm\u259 torul cod imprim\u259  rezultatele a dou\u259  opera\u539 ii pe o colec\u539 ie: \
val numbers = mutableListOf("one", "two", "three", "four", "five\'94) \
val resultList = numbers.map \{ it.length \}.filter \{ it > 3 \} \
println(resultList)\
\
Cu let, pute\uc0\u539 i rescrie exemplul de mai sus, astfel \'eenc\'e2t s\u259  nu atribui\u539 i rezultatul opera\u539 iunilor din list\u259  unei variabile:\
val numbers = mutableListOf("one", "two", "three", "four", "five")\
numbers.map \{ it.length \}.filter \{ it > 3 \}.let \{ \
    println(it)\
    // and more function calls if needed\
\} \
\
Dac\uc0\u259  blocul de cod transmis la let con\u539 ine o singur\u259  func\u539 ie cu ea ca argument, pute\u539 i utiliza referin\u539 a la metod\u259  (::) \'een loc de argumentul lambda:\
\
numbers.map \{ it.length \}.filter \{ it > 3 \}.let(::println)\
\
let este adesea folosit pentru a executa un bloc de cod care con\uc0\u539 ine valori non-nule. Pentru a efectua ac\u539 iuni asupra unui obiect non-null, utiliza\u539 i operatorul de apel sigur ?. pe ea \u537 i cheam\u259  let cu ac\u539 iunile \'een lambda sa.\
\
val str: String? = "Hello"   \
//processNonNullString(str)       // compilation error: str can be null\
val length = str?.let \{ \
    println("let() called on $it")        \
    processNonNullString(it)      // OK: 'it' is not null inside '?.let \{ \}'\
    it.length\
\}\
\
// run\
The context is available as a context ( receiver ).\
The result is a lambda result.\
\
run face la fel ca with, dar este implementat ca o func\uc0\u539 ie de extensie. Deci, cum ar fi let, \'eel pute\u539 i apela pe obiectul context folosind nota\u539 ia punct.\
\
val service = \'85;\
val result = service.run \{ \}\
\
run este util atunci c\'e2nd lambda ini\uc0\u539 ializeaz\u259  obiecte \u537 i calculeaz\u259  valoarea returnat\u259 .\
\
Pute\uc0\u539 i, de asemenea, s\u259  invoca\u539 i rularea ca func\u539 ie non-extensie. Varianta non-extensie a run-ului nu are obiect context, dar returneaz\u259  totu\u537 i rezultatul lambda. Executarea f\u259 r\u259  extensie v\u259  permite s\u259  executa\u539 i un bloc de mai multe instruc\u539 iuni \'een care este necesar\u259  o expresie.\
\
val hexNumberRegex = run \{\
    val digits = "0-9"\
    val hexDigits = "A-Fa-f"\
    val sign = "+-"\
\
    Regex("[$sign]?[$digits$hexDigits]+")\
\}\
\
// apply\
The context object is available as a receiver ( this ).\
The return value is the object itself.\
\
Deoarece apply returneaz\uc0\u259  obiectul context \'een sine, v\u259  recomand\u259 m s\u259  \'eel utiliza\u539 i pentru blocuri de cod care nu returneaz\u259  o valoare \u537 i care opereaz\u259  \'een principal asupra membrilor obiectului receptor. Cel mai frecvent caz de utilizare pentru aplica\u539 ie este configurarea obiectelor. Astfel de apeluri pot fi citite ca \'84aplica\u539 i urm\u259 toarele atribu\u539 ii la obiect\'94.\
\
val adam = Person("Adam").apply \{\
    age = 32\
    city = "London"        \
\}\
println(adam) // Person(name=Adam, age=32, city=London)\
\
// also\
The context object is available as an argument ( it ).\
The return value is the object itself.\
\
Also este util pentru efectuarea unor ac\uc0\u539 iuni care iau obiectul context ca argument. Utiliza\u539 i also pentru ac\u539 iuni care necesit\u259  o referin\u539 \u259  la obiect, mai degrab\u259  dec\'e2t propriet\u259 \u539 ile \u537 i func\u539 iile acestuia, sau c\'e2nd nu dori\u539 i s\u259  umbri\u539 i this referin\u539 \u259  dintr-un domeniu exterior.\
\
C\'e2nd vede\uc0\u539 i also \'een cod, \'eel pute\u539 i citi ca \'84\u537 i, de asemenea, face\u539 i urm\u259 toarele cu obiectul\'94.\
\
val numbers = mutableListOf("one", "two", "three")\
numbers\
    .also \{ println("The list elements before adding new one: $it") \}\
    .add("four\'94)\
\
// 
\f1\fs32 we also have the ability to create new threads or thread pools for coroutines. This is done by creating a new Executor. Executors are objects that execute given tasks. They are usually tied with Runnables, since they wrap the task in a runnable, which needs executing
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // Toast - footer care apare putin in partea de jos si dispare foarte rapid. Eroare pentru devs sau debugging
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // 
\f0\fs24 facade, adapter, proxy, observer, factory patterns\
\
// Observer are 3 states: onNext - when emits a new item to the Observer, onComplete - notifies all the observers that the observable is done with its task, onError - notifies the observer that the Observable experienced an error, onSubscribe\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // Live Data
\f0\fs24 \

\f1\fs32 LiveData is a lifecycle-aware component that wraps around objects you wish to emit in a reactive way, much the same way the Observable object does in RxJava. LiveData is \'93live\'94 in the sense that when the underlying data updates, anything observing that data will also receive the updates. For example, when paired with Room, LiveData retrieved from the Room database automatically updates when the data in the database changes.\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f8 \cf12 \cb5 Unlike a regular observable, LiveData is lifecycle-aware, meaning it respects the lifecycle of other app components, such as activities, fragments, or services. This awareness ensures LiveData only updates app component observers that are in an active lifecycle state.
\f1 \cf0 \cb1 \
\pard\pardeftab720\partightenfactor0

\f8 \cf12 \
\pard\pardeftab720\partightenfactor0
\cf12 \cb5 LiveData considers an observer, which is represented by the {\field{\*\fldinst{HYPERLINK "https://developer.android.com/reference/androidx/lifecycle/Observer"}}{\fldrslt 
\f9 \cf11 \ul \ulc11 Observer}} class, to be in an active state if its lifecycle is in the {\field{\*\fldinst{HYPERLINK "https://developer.android.com/reference/androidx/lifecycle/Lifecycle.State#STARTED"}}{\fldrslt 
\f9 \cf11 \ul \ulc11 STARTED}} or {\field{\*\fldinst{HYPERLINK "https://developer.android.com/reference/androidx/lifecycle/Lifecycle.State#RESUMED"}}{\fldrslt 
\f9 \cf11 \ul \ulc11 RESUMED}} state. LiveData only notifies active observers about updates. Inactive observers registered to watch {\field{\*\fldinst{HYPERLINK "https://developer.android.com/reference/androidx/lifecycle/LiveData"}}{\fldrslt 
\f9 \cf11 \ul \ulc11 LiveData}} objects aren't notified about changes.\cb1 \
\pard\pardeftab720\partightenfactor0

\f1 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /// MVVM - Model-View-ViewModel 
\f0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls3\ilvl0
\f1\fs32 \cf2 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
View displays the UI and informs the other layers about user actions.\'a0
\f0\fs24 \
\ls3\ilvl0
\f1\fs32 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
ViewModel exposes information to the View.\'a0
\f0\fs24 \
\ls3\ilvl0
\f1\fs32 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
Model retrieves information from your datasource and exposes it to the ViewModels
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 Thanks to Google's new Architecture Components, you now have a special class to build your ViewModels called ViewModel. The ViewModel class is specially designed to manage and store information in a lifecycle-aware manner. This means that the data stored inside it can survive configuration/lifecycle changes like screen rotations.\cf0 \
\cf2 The ViewModel remains in memory until the lifecycle object to which it belongs has completely terminated. This behavior applies to activities when they finish and in fragments when they are detached.
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 View -> ViewModel -> Model - au referinta directa, invers nu, nu detin referinta catre p\uc0\u259 rinte, ceea ce inseamna ca model si viewModel vor expune date care vor putea fi observate de catre p\u259 rin\u539 i.
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 // ANR - application not responding dupa 5s blocked pe main thread\
\
// context \
iti da info de orice resursa ce sistemul de operare o da la dispozi\uc0\u539 ie\
informatii globale despre un mediu de aplicatie - permite accesul la reurse si clase specifice aplica\uc0\u539 iei\
\
\pard\pardeftab720\sa320\partightenfactor0

\fs32 \cf10 \cb5 Contexts contain the following information that views require:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls4\ilvl0\cf10 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
device screen size and dimensions for converting dp,sp to pixels\cb1 \
\ls4\ilvl0\cb5 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
styled attributes\cb1 \
\pard\pardeftab720\partightenfactor0
\cf10 \cb5 Application Context and an Activity Context, which last for the duration of their respective lifecycle. Most {\field{\*\fldinst{HYPERLINK "https://guides.codepath.com/android/Defining-Views-and-their-Attributes"}}{\fldrslt \cf11 \ul \ulc11 Views}} should be passed an Activity Context in order to gain access to what themes, styles, dimensions should be applied. In most cases, you should use the Activity Context\cb1 \
\
\cb5 // coroutines context
\fs24 \cf2 \cb1 \

\fs32 \cf10 \
\pard\pardeftab720\partightenfactor0

\fs24 \cf2 Contextul corutinei este un set de diverse elemente. Elementele principale sunt Job-ul corutinei si dispecerul s\uc0\u259 u
\fs32 \cf10 \

\fs24 \cf2 \
\pard\pardeftab720\partightenfactor0

\fs32 \AppleTypeServices\AppleTypeServicesF65539 \cf13 \cb5 The coroutine's {\field{\*\fldinst{HYPERLINK "https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html"}}{\fldrslt \cf11 \ul \ulc11 Job}} is part of its context, and can be retrieved from it using the 
\f6\fs30 \AppleTypeServices \cb1 coroutineContext[Job]
\f0\fs24 \cf2 \
\pard\pardeftab720\partightenfactor0

\f10\fs40 \cf14 \cb5 A coroutine itself
\f11\i  
\f10\i0 is represented by a {\field{\*\fldinst{HYPERLINK "https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html"}}{\fldrslt 
\f6\fs30 \cf11 \cb15 \ul \ulc11 Job}}. It is responsible for coroutine\'92s lifecycle, cancellation, and parent-child relations. 
\f0\fs24 \cf2 \cb1 \
\pard\pardeftab720\partightenfactor0

\fs36 \AppleTypeServices\AppleTypeServicesF65539 \cf10 \cb5 C
\f10\fs40 \AppleTypeServices \cf14 oroutine context is immutable, but you can add elements to a context using {\field{\*\fldinst{HYPERLINK "https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/plus.html"}}{\fldrslt 
\f6\fs30 \cf11 \cb15 \ul \ulc11 plus}} operator, just like you add elements to a set, producing a new context instance
\f0\fs24 \cf2 \cb1 \
\
// public, private, internal(ca si public, doar ca in packet), protected(mostenire, nu sunt visibile in exterior, dar la copii lor)\
\
// activitatea unui UI - onCreate - 
\f8\fs32 \cf12 \cb5 perform basic application startup logic that happens only once for the entire life of the activity. 
\f0\fs24 \cf2 \cb1 , onStart - 
\f8\fs32 \cf12 \cb5 This call makes the activity visible to the user as the app prepares for the activity to enter the foreground and become interactive
\f0\fs24 \cf2 \cb1 , onResume - activitatea e interactionabila, onPause - activitatea nu e interactionabila(
\f8\fs32 \cf12 \cb5 As long as the activity is partially visible but not in focus, it remains paused - multi window)
\f0\fs24 \cf2 \cb1 , onStop - activitatea nu mai e vizibila, onDestroy - activitatea e distrus\uc0\u259 \
\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 private 
\f0\fs24 \

\f1\fs32 The private modifier is the most restrictive we can use. It indicates it is visible in its file. So if we declare a class as private, we are not able to use it outside the file where it was defined. On the other hand, if we use private inside a class, the access is restricted to that class. Even classes that extend it cannot use it. So first level classes, objects, interfaces\'85 (known as package members) declared as private are only visible inside the file where they are declared, while everything defined inside a class or interface is only visible by that class or interface. 
\f0\fs24 \

\f1\fs32 protected 
\f0\fs24 \

\f1\fs32 This modifier only applies to members of a class or an interface. A package member cannot be protected. Inside a member, it works the same way as in Java: it can be used by the member itself and the members that extend it (for instance, a class and its subclasses).
\f0\fs24 \

\f1\fs32  internal 
\f0\fs24 \

\f1\fs32 An internal member is visible inside the whole module if it is a package member. If it is a member of another scope, it depends on the visibility of the scope. For instance, if we write a private class, the access to an internal function is limited to the visibility of the class. We can use internal classes from any other class in the same module, but not from another module.
\f0\fs24 \

\f1\fs32 public 
\f0\fs24 \

\f1\fs32 As you may guess, this is the less restrictive modifier. ** It is the default modifier**, and a member declared as public is visible anywhere, only restricted by its scope. A public member defined in a private class will not be visible outside the scope where the class is visible
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // flows
\f0\fs24 \
flow  ca si coroutine cu emit si apoi le iau cu collect sau collectLatest. flow-ul nu face nimic atata timp cat nu sunt subscriberi - asta e cold flow\
un hot flow - emite desi nu sunt colectori, adica subscriberi\

\f1\fs32 -collect (le ia pe rand, chit ca dureaza si are delay-uri collect-ul) 
\f0\fs24 \

\f1\fs32 -collectLatest (daca are delay si ii tot vin pe collect, anuleaza tot ce are si ia ultimul colect si tot asa)
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 Reduce,filter, flatmap - pe flows
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 Buffer, conflate cu collect ca sa nu se faca delay in aceeasi coroutine, practic vor rula pe coroutine separate. Buffer le ia pe toate, cu conflate daca sunt 2 trimise, va lua pe ultima
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 state flow - se bazeaza pe o valoare, isi notifica toti colectorii, si persista si la rotate pentru ca isi va notifica din nou colectorii ( hot flow). Trimite aceeasi valoare la toti subcriberii
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 repeatOnLifecycle - sa ii zici pe ce lifecycle sa func\uc0\u539 ioneze
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 shared flow - one time emission, nu va notifica iar si la rotate de device. daca nu sunt colectori, eventul va fi pierdut daca e primit ( ca si hot flow ). Daca ii dai replay = number, poti face cache de number events si cand noi colectori fac subscribe la flow, ei primesc events-urile. Trimite aceeasi instan\uc0\u539 \u259   la toti subcriberii
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // flow-uri, state flow-uri - functioneaza pe baza de coroutine, fata de livedata care foloseste thread-uri}